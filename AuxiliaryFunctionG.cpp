//
// Created by Xiaoyun Fu on 9/15/2022.
//

#include "AuxiliaryFunctionG.h"
#include <time.h>
#include <cmath>




AuxiliaryFunctionG::AuxiliaryFunctionG(Function& givenFunction, int numGroups):f(givenFunction)
{
    srand(time(0));
    n = f.getGroundSetSize();
    epsilon = 0.1;
    r = numGroups;// rank = k
    c = 1.0;//curvature = 1
    alpha = 1.0; // =1
    I = computeI();
    N = computeN();
    ProbabilityDistribution = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};

}

double AuxiliaryFunctionG::functionValue(vector<int> aSet)
{
    return approximateG(N, aSet);
}

double AuxiliaryFunctionG::functionValue(int node)
{
    vector<int> aSet{node};
    return approximateG(N, aSet);
}

double AuxiliaryFunctionG::marginalGain(int v, vector<int> aSet) //returns a value of g(aSet ∪ {v}) - g(aSet)
{
    vector<int> biggerSet = aSet;
    biggerSet.push_back(v);
    return functionValue(biggerSet) - functionValue(aSet);
}

double AuxiliaryFunctionG::marginalGain(vector<int> A, vector<int> aSet)//returns a value of g(aSet ∪ A) - g(aSet)
{
    vector<int> biggerSet = aSet;
    for(int v: A)
    {
        if(find(aSet.begin(), aSet.end(), v) == aSet.end()) //only add non-duplicate items
        {
            biggerSet.push_back(v);
        }
    }
    return functionValue(biggerSet) - functionValue(aSet);
}

AuxiliaryFunctionG::~AuxiliaryFunctionG()
{

}
int AuxiliaryFunctionG::getGroundSetSize()
{
    return n;
}


bool AuxiliaryFunctionG::isIntersected(vector<int> small, const vector<int>& big)
{
    for(int ele : small)
    {
        if(find(big.begin(),big.end(),ele) != big.end()) //they intersect
            return true;
    }
    return false;
}

vector<vector<int>>* AuxiliaryFunctionG::getRandomRRSetsForInfluenceMaximization()
{
    return myGraph->getRandomRRSetsForInfluenceMaximization();
}
int AuxiliaryFunctionG::getNumOfRRSets()
{
    return R;
}
vector<vector<int>>* AuxiliaryFunctionG::getGraph()
{
    return myGraph->getGraph();
}


//compute the constant epsilon2 as epsilon / (4 * r * HarmoicHumber(r))
double AuxiliaryFunctionG::computeEpsilon2()
{
    return epsilon * 1.0 / (4 * r * HarmonicNumber(r));
}


// compute the constant I as [(1+epsilon2)/(1- epsilon2)  * ( 2 + 3*r*epsilon2)    -  1]/epsilon2
int AuxiliaryFunctionG::computeI()
{
    double epsilon2 = computeEpsilon2();
    int result = (  ((1+epsilon2) / (1-epsilon2)) * (2 + 3 * r * epsilon2) - 1) / epsilon2;
    cout << "I = " << result << endl;
    return result;

}


//compute the constant N as 1/2  *  [ c * e^c * HarmonicNumber(n)  / ((e^c - 1)* epsilon2) ]^2  * ln [(1+I) * r * n^(1+alpha)]
int AuxiliaryFunctionG::computeN()
{
    double epsilon2 = computeEpsilon2();
    cout << "epsilon2 = " << epsilon2 << endl;
    double squarePart = (c * pow(exp(1.0),c) * HarmonicNumber(n))/((pow(exp(1.0),c) - 1) * epsilon2);
    squarePart = squarePart * squarePart;
    cout << "squarePart = " << squarePart << endl;
    double logPart = (I + 1.0) * r * pow(n, 1+ alpha);
    logPart = log(logPart);
    cout <<"logPart = " << logPart << endl;

    int result = (1.0/2) * squarePart * logPart;
    cout << "N = " << result << endl;
    return result;
}

int AuxiliaryFunctionG::getI()
{
    return I;
}

int AuxiliaryFunctionG::getN()
{
    return N;
}

//Takes an int j as input
//Returns the jth Harmonic Number, i.e. 1 + 1/2 + 1/3 + ... + 1/j
double AuxiliaryFunctionG::HarmonicNumber(int j)
{
    double result = 0.0;
    for(int i = 1; i <= j; i++)
        result += (1.0/i);
    return result;
}

double AuxiliaryFunctionG::getEpsilon2() {
    return epsilon2;
}



//an approximation to g(S)
// taking N random samples B as a subset of S, then output the average of f(B)'s
double AuxiliaryFunctionG::approximateG(int N, vector<int> S)
{
    double cumulativeFunctionValue = 0.0;
    for(int i = 0; i < N; i++)
    {
        vector<int> B = sampleOf(S);
        cumulativeFunctionValue += f.functionValue(B);
    }
    return cumulativeFunctionValue/N;
}

//Takes a vector<int> S as input,
//returns a subset B of S.
// Each B is generated by uniformaly at random choose p from P = {0.1, 0.2, ... 1],
// then add each element v in S to B with probability p.
vector<int> AuxiliaryFunctionG::sampleOf(vector<int> S)
{
    vector<int> B;
    int p = ProbabilityDistribution[rand()%10];
    for(int node : S)
    {
        double randomNumber = rand() * 1.0 / RAND_MAX;
        if(randomNumber <= p)
            B.push_back(node);
    }
    return B;
}
