/*
 * In this class, we verify the k/(2k-1) guarantee of our k-greedy algorithm for the equal submodular
 * optimization problem.
 * We compute our k-greedy algorithm output S which takes O(kn) time, then compare it with
 * the optimal solution S* obtained from a brute-force search of the solution space which takes O(n^k) time.
 */



#include "Function.h"
#include "kGreedy.h"
#include "BruteForce.h"
#include "InfluenceFunction.h"
#include "SimpleFunction.h"
#include "CoverFunction.h"
#include "ReachabilityFunction.h"
#include "AssignGroups.h"

#include <ctime>    // For time()
#include <chrono>
#include <iostream>
#include <fstream>
#include <cassert>

void printSeedSet(vector<int> seedSet, ofstream& log);
int main()
{
//constants
    const int NUM_RUNS = 5;
    const string INFLUENCE_FUNCTION = "Influence Function";
    const string COVER_FUNCTION = "Cover Function";
    const string REACHABILITY_FUNCTION = "Reachability Function";
    const string RANDOM_STARTEGY = "Random";
    const string SCREEN_INFLUENCERS = "Screen Influencers";


    //parameters
    string graphName = "CA-GrQcSim.txt";
    string graphPath =  "/home/me/RepresentativeSubmodularMaximization/graphs/";
    double edgeProbability = 0.02;  //used for influence function
    double percent = 0.01;
    int numOfGroups = 2;
    string outputPath = "/home/me/Desktop/logger.txt";

    string groupStrategy = RANDOM_STARTEGY;
//    string groupStrategy = SCREEN_INFLUENCERS;

    string functionName = COVER_FUNCTION;  // COVER_FUNCTION; REACHABILITY_FUNCTION
    CoverFunction f(graphPath + graphName);

//    string functionName = INFLUENCE_FUNCTION;
//    InfluenceFunction f(graphPath + graphName, edgeProbability);

//    string functionName = REACHABILITY_FUNCTION;
//    ReachabilityFunction f(graphPath + graphName);


//================================Actual Experiements========================================================
    int groundSetSize = f.getGroundSetSize();  // need to change this to graph size
    AssignGroups assignGroups(groundSetSize, numOfGroups, f);

    for(int j = 0; j < NUM_RUNS; j++) {

        //logging purpose
        ofstream logbook;
        logbook.open(outputPath, fstream::app);
        auto start = std::chrono::system_clock::now();
        std::time_t start_time = std::chrono::system_clock::to_time_t(start);
        logbook << std::ctime(&start_time);
        logbook << "graph name: " << graphName << endl;
        logbook << "n = " << f.getGroundSetSize() <<  endl;
        if (functionName == INFLUENCE_FUNCTION)
            logbook << "edge probability is set to " << edgeProbability << endl;

        //assign the groups
        vector<vector<int>> groups;
        if(groupStrategy == RANDOM_STARTEGY)
        {
            groups = assignGroups.assignGroupsRandomly();
            logbook<< numOfGroups << " groups are generated by " << "randomly assign each node to a group" << endl;
        }
        else if(groupStrategy == SCREEN_INFLUENCERS)
        {
            groups = assignGroups.assignGroupsAccordingToMarginalGainWithRespectToEmaxForInfluenceFunction(numOfGroups, percent) ;
            logbook << numOfGroups << " are generated by putting e_max in G0, all v with f(v|e_max) > f(e_max) * "
                    << percent << " in G0, and rest of nodes randomly" << endl;
        }

        for (int i = 0; i < groups.size(); i++)
            logbook << "group[" << i << "].size() = " << groups[i].size() << ", ";
        logbook << endl;


        assert (groups.size() == numOfGroups);   //check if there are empty groups generated
        logbook<< "Compare k-greedy algorithm with Brute force algorithm using " << functionName << endl;

        kGreedy kgreedy(f, groups, numOfGroups);
        double functionValueOfX;
        clock_t startTime1 = clock(); //using <ctime> library
        vector<int> X;
        if(functionName == INFLUENCE_FUNCTION)
        {
            X = kgreedy.kGreedyAlgorithmForInfluenceFunction(functionValueOfX);
        }
        else if (functionName == COVER_FUNCTION)
        {
            X = kgreedy.kGreedyAlgorithmForCoverFunction(functionValueOfX);
        }
        else if (functionName == REACHABILITY_FUNCTION)
        {
            X = kgreedy.kGreedyAlgorithmForReachabilityFunction(functionValueOfX);
        }
        clock_t endTime1 = clock();
        double timeFindingSeedSetX = double(endTime1 - startTime1) / CLOCKS_PER_SEC; //unit is seconds
        logbook << "Time to find the best seed set for k-greedy algorithm: " << timeFindingSeedSetX << " seconds."
                << endl;
        cout << "seed set for k-greedy algorithm found" << endl;
        logbook << "f(k-greedy algorithm seed set X) = " << functionValueOfX << "with X = ";
        printSeedSet(X, logbook);
        logbook << "--------------------------------------------------------------------------------------" << endl;



        BruteForce bruteForce(f,groups,numOfGroups);
        double functionValueOfZ;
        clock_t startTime3 = clock(); //using <ctime> library
        vector<int> Z = bruteForce.BruteForceAlgorithm(functionValueOfZ);
        clock_t endTime3 = clock();
        double timeFindingSeedSetZ = double(endTime3 - startTime3) / CLOCKS_PER_SEC; //unit is seconds
        logbook << "Time to find the best seed set for brute-force algorithm: " << timeFindingSeedSetZ << " seconds." << endl;
        cout << "seed set for brute-force algorithm found" << endl;
        logbook << "f(brute-force algorithm seed set Z) = " << functionValueOfZ << "with Z = " ;
        printSeedSet(Z, logbook);
        logbook << "--------------------------------------------------------------------------------------"<< endl;

        logbook << "Theoretical guarantee = " << 1.0 * numOfGroups/(2 * numOfGroups - 1) << endl;
        logbook << "Actual      guarantee = " << 1.0* functionValueOfX/functionValueOfZ << endl;
        logbook << "======================================================================================" << endl << endl;



        logbook << "======================================================================================" << endl
                << endl;
    }


}



void printSeedSet(vector<int> seedSet, ofstream& log)
{
    log << endl;
    log << "Seed set size: " << seedSet.size() << endl;
    log << "Seed Nodes: ";
    for(int ele : seedSet){
        log << ele << ", ";
    }
    log << endl;
}